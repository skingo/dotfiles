Delivered-To: ingo.skupin@gmail.com
Received: by 10.58.150.162 with SMTP id uj2csp109569veb;
        Sat, 24 May 2014 07:52:02 -0700 (PDT)
X-Received: by 10.180.11.178 with SMTP id r18mr11793963wib.41.1400943121521;
        Sat, 24 May 2014 07:52:01 -0700 (PDT)
Return-Path: <silkeczarn@yahoo.de>
Received: from nm32.bullet.mail.ir2.yahoo.com (nm32.bullet.mail.ir2.yahoo.com. [212.82.96.57])
        by mx.google.com with ESMTPS id lx10si7745627wjb.12.2014.05.24.07.52.00
        for <ingo.skupin@gmail.com>
        (version=TLSv1 cipher=RC4-SHA bits=128/128);
        Sat, 24 May 2014 07:52:01 -0700 (PDT)
Received-SPF: none (google.com: silkeczarn@yahoo.de does not designate permitted sender hosts) client-ip=212.82.96.57;
Authentication-Results: mx.google.com;
       spf=neutral (google.com: silkeczarn@yahoo.de does not designate permitted sender hosts) smtp.mail=silkeczarn@yahoo.de;
       dkim=pass header.i=@yahoo.de;
       dmarc=pass (p=NONE dis=NONE) header.from=yahoo.de
Received: from [212.82.98.57] by nm32.bullet.mail.ir2.yahoo.com with NNFMP; 24 May 2014 14:52:00 -0000
Received: from [46.228.39.83] by tm10.bullet.mail.ir2.yahoo.com with NNFMP; 24 May 2014 14:52:00 -0000
Received: from [127.0.0.1] by smtp120.mail.ir2.yahoo.com with NNFMP; 24 May 2014 14:52:00 -0000
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.de; s=s1024; t=1400943120; bh=NnoYDv3ErbHChV3D2gYKtOCm4Na/sjF3B+CdO/vnKkY=; h=X-Yahoo-Newman-Id:X-Yahoo-Newman-Property:X-YMail-OSG:X-Yahoo-SMTP:X-Rocket-Received:Message-ID:Date:From:User-Agent:MIME-Version:To:Subject:Content-Type; b=R3KlYuGB2n3ZQIlnx4PmprjDq5pGKKe3XA0FZ2bhC00x0CuPPicFzZ9/Zp/6E50QxBejwBHYzOqxRt9uS6Vmq9lbceOL7tPSniZt9iOA1ckDLM8LqkhQI/nAmHpaczyh9caSX9i+HcXMDctO+cTifP0DCDHi0HxScPPYVDkt9PA=
X-Yahoo-Newman-Id: 479500.84911.bm@smtp120.mail.ir2.yahoo.com
X-Yahoo-Newman-Property: ymail-3
X-YMail-OSG: 26q.wAYVM1mMJXM78HpjIWTE0zl9hMEC_zDRJURdtCR_g0w
 N6hj9CULOJFGhOD3gxQM3uB5CDrKzQLX4JR1IFhUc.hKHNxrw534noptcOZd
 HeYoDqHlqIfne02v4Xp3PlU3o0BO7rStEgbzY1aGFns4yD4BdWi_uIoPFqBU
 s7hphHykPQo_jc57uVlLqEo7mH.cTsBdQrlk2FbhNrHVbqmIKmihe4nnznLR
 XfcnqEQ5vH9aFLwECxP42UzEENZHwlJl4o1sIgMSrfTYHIj84deqEYs1QKSt
 ukJ3mlnyuhMEay.KmzR9HdZRcYptxmt21JlB7DLWi.CHeLnSE2MtCH5PwnFQ
 saBzB7PI0ds9gBc0nceBKz2NpYsHP9i0YGON402yhWoZaW5brxy0SZdEtIyx
 wuIIyWF.Kjn3wH_omVDi7r3XlUuiaPLxKiYDvXZ.1MWfdVHMSj7XDwu0zaxy
 6Sb0e5CNA.7gmqdeZ2YQsUTvPSDcE6Nxax70lGRGjoaPXe613rhSgq3pD66Q
 nfkaYkwvQxk32d70aG07QW5mHPg--
X-Yahoo-SMTP: DpzBWgGswBBCrqc17gq8BnpqtJD1tMY-
X-Rocket-Received: from [127.0.0.1] (silkeczarn@95.112.7.14 with plain [188.125.69.59])
        by smtp120.mail.ir2.yahoo.com with SMTP; 24 May 2014 14:52:00 +0000 UTC
Message-ID: <5380B1F9.7020504@yahoo.de>
Date: Sat, 24 May 2014 16:51:37 +0200
From: Silke Czarnetzki <silkeczarn@yahoo.de>
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Thunderbird/24.5.0
MIME-Version: 1.0
To: Ingo Skupin <ingo.skupin@googlemail.com>
Subject: FP Blatt
Content-Type: multipart/mixed;
 boundary="------------000103030209040703060405"

This is a multi-part message in MIME format.
--------------000103030209040703060405
Content-Type: text/plain; charset=ISO-8859-15; format=flowed
Content-Transfer-Encoding: 8bit

Hello Ingo,

das ist ja mal one hell of a workload.
Ich hab dir mal angehängt, was ich schon hab. Die show aus Aufgabe 2 
funktioniert und die evalExpr sollte auch mit ein paar Einschränkungen 
funktionieren, wenn ich alles richtig verstanden habe.
Ich geh beispielsweise davon aus, dass die Attribute in der Expression, 
in der gleichen Reihenfolge vorliegen, wie in der Tabelle. Sonst wär's 
mir zu dumm geworden.
Zu mehr bin ich noch nicht gekommen. Urgs...
Kannst ja mal drüberschauen.

LG,
Silke


--------------000103030209040703060405
Content-Type: text/x-haskell;
 name="RelAlgebraCommon.hs"
Content-Transfer-Encoding: 8bit
Content-Disposition: attachment;
 filename="RelAlgebraCommon.hs"

-- FP assignment 05

-- Provided code: Relation types, operator expressions

-- Use the following Unicode symbols for relational operators:
-- Selection:     Ïƒ (GREEK SMALL LETTER SIGMA)
-- Project:       Ï€ (GREEK SMALL LETTER PI)
-- Cross Product: Ã— (MULTIPLICATION SIGN)
-- Union:         âˆª (UNION)
-- Difference:    âˆ– (SET MINUS)

-- | Common types and helper functions for relational algebra DSLs.
module RelAlgebraCommon
    ( -- * Types that define relations.
      RelAttr
    , AtomVal(..)
    , Row
    , Schema
    , Relation(Rel)
    , schema
    , inst
      -- * Scalar expressions for projection and selection.
    , QExpr
      -- * Expression constructors
    , (.==.)
    , (.<.)
    , (.>.)
    , attr
    , int
    , bool
    , str
    , mkRel
    ) where

-- | An attribute's name
type RelAttr = String

-- | Atomic values
data AtomVal = IntV Int 
             | StringV String 
             | BoolV Bool
             deriving (Eq, Show)

-- | A tuple in a relation.
newtype Row = R [AtomVal] deriving Eq

-- | A (untyped) schema contains the names of a relation's attributes.
type Schema = [RelAttr]

-- | A relation consists of a schema and an instance.
data Relation = Rel 
    { schema :: Schema
    , inst   :: [Row] 
    }

-- | Binary (comparison) operators
data Op = Eq | Lt | Gt deriving (Show)

-- | Scalar expressions for projections and selection predicates.
data QExpr = AttrRef RelAttr     -- ^ A reference to an attribute in the
                                 -- current row
           | LitVal AtomVal      -- ^ A literal atomic value
           | App Op QExpr QExpr  -- ^ Application of binary operators
           deriving (Show)

-- | Construct a relation from a schema and a list of tuples.
mkRel :: Schema -> [[AtomVal]] -> Relation
mkRel sch rs = Rel { schema = sch, inst = map R rs }

--------------------------------------------------------------------
-- Expression constructors

(.==.) :: QExpr -> QExpr -> QExpr
(.==.) = App Eq

(.<.) :: QExpr -> QExpr -> QExpr
(.<.) = App Lt

(.>.) :: QExpr -> QExpr -> QExpr
(.>.) = App Gt

attr :: RelAttr -> QExpr
attr = AttrRef

int :: Int -> QExpr
int = LitVal . IntV

bool :: Bool -> QExpr
bool = LitVal . BoolV

str :: String -> QExpr
str = LitVal . StringV

--------------------------------------------------------------------
-- Assignment

-- evaluates an expression on a tuple
evalExpr :: Schema -> Row -> QExpr -> AtomVal
-- any expression evalues to false an empty row
evalExpr _ (R []) _ = (BoolV False)
-- Lt and Gt only applicable to IntV values
evalExpr (column:columns) (R ((IntV x):xs)) (App operator (AttrRef attr) (LitVal (IntV value))) | (attr == column) = case operator of
																														Eq -> BoolV (x == value)
																														Lt -> BoolV (x < value)
																														Gt -> BoolV (x > value)
																								| otherwise			    = evalExpr columns (R xs) (App operator (AttrRef attr) (LitVal (IntV value)))
evalExpr (column:columns) (R (x:xs))        (App operator (AttrRef attr) (LitVal value))		| (attr == column) = case operator of
																														Eq -> BoolV (x == value)
																														Lt -> error "(.<.) not applicable to String or Bool"
																														Gt -> error "(.>.) not applicable to String or Bool"
																								| otherwise			    = evalExpr columns (R xs) (App operator (AttrRef attr) (LitVal value))
																								
-- if attribute is in second position instead of in first simply change the order of the arguments and use Lt instead of Gt and vice versa
evalExpr (column:columns) (R (x:xs))        (App operator (LitVal value) (AttrRef attr))		= case operator of 
																									Eq -> evalExpr (column:columns) (R (x:xs)) (App operator (AttrRef attr) (LitVal value))
																									Lt -> evalExpr (column:columns) (R (x:xs)) (App Gt		 (AttrRef attr) (LitVal value))
																									Gt -> evalExpr (column:columns) (R (x:xs)) (App Lt		 (AttrRef attr) (LitVal value))

-- assume that first attribute is a column smaller than or equal to the second attribute
																								-- change found first attribute to LitVal and call function with corresponding atomic value
evalExpr (column:columns) (R (x:xs))        (App operator (AttrRef attr1) (AttrRef attr2))		| (attr1 == column) = evalExpr (column:columns) (R (x:xs)) (App operator (LitVal x) (AttrRef attr2))
																								| otherwise 		= evalExpr columns (R xs) (App operator (AttrRef attr1) (AttrRef attr2))

-- evaluates a projection on a tuple
evalProj :: Schema -> Row -> [(RelAttr,QExpr)] -> Row
evalProj _ (R []) _ = (R [])
-- empty projection
evalProj _ row	 [] = row
evalProj (column:columns) (R (r:rs)) (p:ps) = case p of
											 -- projection only renames
											 (attr, AttrRef attrRef)		     -> if (attr == column)
																						then evalProj columns (R (r:rs)) ps
																						else evalProj columns (R rs)  (p:ps)
											 (attr, expression) 				 -> if (attr == column)
																						then evalProj columns (R ((evalExpr (column:columns) (R (r:rs)) expression):rs)) ps
																						else evalProj columns (R rs)   (p:ps)


--------------000103030209040703060405
Content-Type: text/x-haskell;
 name="SetLanguageDeepCard.hs"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="SetLanguageDeepCard.hs"

module SetLanguageDeepCard (IntegerSet(Empty, Insert, Delete),
                            member,
                            card) where

data IntegerSet =
    Empty
  | Insert IntegerSet Integer
  | Delete IntegerSet Integer

-- TODO: build a suitable Show instance for IntegerSet

instance Show IntegerSet where
	show Empty = "{}"
	show (Insert Empty x) = "{" ++ show x ++ "}"
	show (Insert xs x) | member xs x = "{" ++ (removeBraces $ show xs) ++ "}"
					   | otherwise   = "{" ++ (show x) ++ "," ++ (removeBraces $ show xs) ++ "}"
					   -- remove braces removes the first and last character of a string
					   -- here: "{" and "}"
					   where removeBraces xs = drop 1 $ take ((length xs)-1) xs
	show (Delete xs x) | member xs x = 
						-- splits string in two parts, prefix not containing x and suffix containing x
						-- removes x and remaining comma
						-- here: delete {2,3,4} 3 -> [["2,"],["3,4"]] -> [["2"],[",4"]]
						let 
							charX		  = (head $ show x)
							removeBraces  = drop 1 $ take ((length (show xs))-1) (show xs)
							splitAtX      = (takeWhile (/= charX) removeBraces) : (dropWhile (/= charX) removeBraces) : []
							firstPart     = head $ splitAtX
							secondPart    = head $ tail $ splitAtX
							removeX       =  if firstPart == [] then firstPart ++ (drop 2 secondPart) else (take ((length firstPart)-1) firstPart) ++ (drop 1 secondPart)
						in "{" ++ removeX ++ "}"
					   | otherwise = show xs 

member :: IntegerSet -> Integer -> Bool
member Empty         _ = False
member (Insert xs x) y = x == y || member xs y
member (Delete xs x) y = x /= y && member xs y



card :: IntegerSet -> Int
card Empty = 0
card (Insert xs x)
  | member xs x = card xs
  | otherwise   = 1 + card xs
card (Delete xs x)
  | member xs x = card xs - 1
  | otherwise   = card xs
  

maximumSet :: IntegerSet -> Integer
maximumSet  Empty           = undefined
maximumSet (Insert Empty x) = x
maximumSet (Insert xs    x) | x > (maximumSet xs) = x
						    | otherwise 		  = maximumSet xs
maximumSet (Delete xs    x) | member xs x		  = case xs of
														(Insert ys y) -> 42
														(Delete ys y) -> 42
							| otherwise           = maximumSet xs
--------------000103030209040703060405--
